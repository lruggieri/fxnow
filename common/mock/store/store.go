// Code generated by mockery v2.20.2. DO NOT EDIT.

package mockstore

import (
	context "context"

	store "github.com/lruggieri/fxnow/common/store"
	mock "github.com/stretchr/testify/mock"
)

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

type Store_Expecter struct {
	mock *mock.Mock
}

func (_m *Store) EXPECT() *Store_Expecter {
	return &Store_Expecter{mock: &_m.Mock}
}

// CreateAPIKey provides a mock function with given fields: ctx, req
func (_m *Store) CreateAPIKey(ctx context.Context, req store.CreateAPIKeyRequest) (*store.CreateAPIKeyResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *store.CreateAPIKeyResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.CreateAPIKeyRequest) (*store.CreateAPIKeyResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.CreateAPIKeyRequest) *store.CreateAPIKeyResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*store.CreateAPIKeyResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.CreateAPIKeyRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateAPIKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAPIKey'
type Store_CreateAPIKey_Call struct {
	*mock.Call
}

// CreateAPIKey is a helper method to define mock.On call
//   - ctx context.Context
//   - req store.CreateAPIKeyRequest
func (_e *Store_Expecter) CreateAPIKey(ctx interface{}, req interface{}) *Store_CreateAPIKey_Call {
	return &Store_CreateAPIKey_Call{Call: _e.mock.On("CreateAPIKey", ctx, req)}
}

func (_c *Store_CreateAPIKey_Call) Run(run func(ctx context.Context, req store.CreateAPIKeyRequest)) *Store_CreateAPIKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(store.CreateAPIKeyRequest))
	})
	return _c
}

func (_c *Store_CreateAPIKey_Call) Return(_a0 *store.CreateAPIKeyResponse, _a1 error) *Store_CreateAPIKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_CreateAPIKey_Call) RunAndReturn(run func(context.Context, store.CreateAPIKeyRequest) (*store.CreateAPIKeyResponse, error)) *Store_CreateAPIKey_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: ctx, req
func (_m *Store) CreateUser(ctx context.Context, req store.CreateUserRequest) (*store.CreateUserResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *store.CreateUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.CreateUserRequest) (*store.CreateUserResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.CreateUserRequest) *store.CreateUserResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*store.CreateUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.CreateUserRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type Store_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - req store.CreateUserRequest
func (_e *Store_Expecter) CreateUser(ctx interface{}, req interface{}) *Store_CreateUser_Call {
	return &Store_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, req)}
}

func (_c *Store_CreateUser_Call) Run(run func(ctx context.Context, req store.CreateUserRequest)) *Store_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(store.CreateUserRequest))
	})
	return _c
}

func (_c *Store_CreateUser_Call) Return(_a0 *store.CreateUserResponse, _a1 error) *Store_CreateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_CreateUser_Call) RunAndReturn(run func(context.Context, store.CreateUserRequest) (*store.CreateUserResponse, error)) *Store_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAPIKey provides a mock function with given fields: ctx, req
func (_m *Store) DeleteAPIKey(ctx context.Context, req store.DeleteAPIKeyRequest) (*store.DeleteAPIKeyResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *store.DeleteAPIKeyResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.DeleteAPIKeyRequest) (*store.DeleteAPIKeyResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.DeleteAPIKeyRequest) *store.DeleteAPIKeyResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*store.DeleteAPIKeyResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.DeleteAPIKeyRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_DeleteAPIKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAPIKey'
type Store_DeleteAPIKey_Call struct {
	*mock.Call
}

// DeleteAPIKey is a helper method to define mock.On call
//   - ctx context.Context
//   - req store.DeleteAPIKeyRequest
func (_e *Store_Expecter) DeleteAPIKey(ctx interface{}, req interface{}) *Store_DeleteAPIKey_Call {
	return &Store_DeleteAPIKey_Call{Call: _e.mock.On("DeleteAPIKey", ctx, req)}
}

func (_c *Store_DeleteAPIKey_Call) Run(run func(ctx context.Context, req store.DeleteAPIKeyRequest)) *Store_DeleteAPIKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(store.DeleteAPIKeyRequest))
	})
	return _c
}

func (_c *Store_DeleteAPIKey_Call) Return(_a0 *store.DeleteAPIKeyResponse, _a1 error) *Store_DeleteAPIKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_DeleteAPIKey_Call) RunAndReturn(run func(context.Context, store.DeleteAPIKeyRequest) (*store.DeleteAPIKeyResponse, error)) *Store_DeleteAPIKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetAPIKey provides a mock function with given fields: ctx, req
func (_m *Store) GetAPIKey(ctx context.Context, req store.GetAPIKeyRequest) (*store.GetAPIKeyResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *store.GetAPIKeyResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.GetAPIKeyRequest) (*store.GetAPIKeyResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.GetAPIKeyRequest) *store.GetAPIKeyResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*store.GetAPIKeyResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.GetAPIKeyRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetAPIKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAPIKey'
type Store_GetAPIKey_Call struct {
	*mock.Call
}

// GetAPIKey is a helper method to define mock.On call
//   - ctx context.Context
//   - req store.GetAPIKeyRequest
func (_e *Store_Expecter) GetAPIKey(ctx interface{}, req interface{}) *Store_GetAPIKey_Call {
	return &Store_GetAPIKey_Call{Call: _e.mock.On("GetAPIKey", ctx, req)}
}

func (_c *Store_GetAPIKey_Call) Run(run func(ctx context.Context, req store.GetAPIKeyRequest)) *Store_GetAPIKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(store.GetAPIKeyRequest))
	})
	return _c
}

func (_c *Store_GetAPIKey_Call) Return(_a0 *store.GetAPIKeyResponse, _a1 error) *Store_GetAPIKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetAPIKey_Call) RunAndReturn(run func(context.Context, store.GetAPIKeyRequest) (*store.GetAPIKeyResponse, error)) *Store_GetAPIKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function with given fields: ctx, req
func (_m *Store) GetUser(ctx context.Context, req store.GetUserRequest) (*store.GetUserResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *store.GetUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.GetUserRequest) (*store.GetUserResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.GetUserRequest) *store.GetUserResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*store.GetUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.GetUserRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type Store_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - req store.GetUserRequest
func (_e *Store_Expecter) GetUser(ctx interface{}, req interface{}) *Store_GetUser_Call {
	return &Store_GetUser_Call{Call: _e.mock.On("GetUser", ctx, req)}
}

func (_c *Store_GetUser_Call) Run(run func(ctx context.Context, req store.GetUserRequest)) *Store_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(store.GetUserRequest))
	})
	return _c
}

func (_c *Store_GetUser_Call) Return(_a0 *store.GetUserResponse, _a1 error) *Store_GetUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetUser_Call) RunAndReturn(run func(context.Context, store.GetUserRequest) (*store.GetUserResponse, error)) *Store_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListAPIKeys provides a mock function with given fields: ctx, req
func (_m *Store) ListAPIKeys(ctx context.Context, req store.ListAPIKeysRequest) (*store.ListAPIKeysResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *store.ListAPIKeysResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.ListAPIKeysRequest) (*store.ListAPIKeysResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.ListAPIKeysRequest) *store.ListAPIKeysResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*store.ListAPIKeysResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.ListAPIKeysRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListAPIKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAPIKeys'
type Store_ListAPIKeys_Call struct {
	*mock.Call
}

// ListAPIKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - req store.ListAPIKeysRequest
func (_e *Store_Expecter) ListAPIKeys(ctx interface{}, req interface{}) *Store_ListAPIKeys_Call {
	return &Store_ListAPIKeys_Call{Call: _e.mock.On("ListAPIKeys", ctx, req)}
}

func (_c *Store_ListAPIKeys_Call) Run(run func(ctx context.Context, req store.ListAPIKeysRequest)) *Store_ListAPIKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(store.ListAPIKeysRequest))
	})
	return _c
}

func (_c *Store_ListAPIKeys_Call) Return(_a0 *store.ListAPIKeysResponse, _a1 error) *Store_ListAPIKeys_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListAPIKeys_Call) RunAndReturn(run func(context.Context, store.ListAPIKeysRequest) (*store.ListAPIKeysResponse, error)) *Store_ListAPIKeys_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewStore interface {
	mock.TestingT
	Cleanup(func())
}

// NewStore creates a new instance of Store. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewStore(t mockConstructorTestingTNewStore) *Store {
	mock := &Store{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
